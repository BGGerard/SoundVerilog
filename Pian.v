/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_DCM_SP #(
    parameter integer CLKFX_DIVIDE = 1,
    parameter integer CLKFX_MULTIPLY = 2,
    parameter real CLKIN_PERIOD = 10.0
)
(
    input cin,
    output cout
);
    // DCM_SP: Digital Clock Manager
    // Spartan-6
    // Xilinx HDL Libraries Guide, version 14.1

    DCM_SP #(
        .CLKDV_DIVIDE(2.0),     // CLKDV divide value
                                // (1.5,2,2.5,3,3.5,4,4.5,5,5.5,6,6.5,7,7.5,8,9,10,11,12,13,14,15,16).
        .CLKFX_DIVIDE(CLKFX_DIVIDE),       // Divide value on CLKFX outputs - D - (1-32)
        .CLKFX_MULTIPLY(CLKFX_MULTIPLY),   // Multiply value on CLKFX outputs - M - (2-32)
        .CLKIN_DIVIDE_BY_2("FALSE"),       // CLKIN divide by two (TRUE/FALSE)
        .CLKIN_PERIOD(CLKIN_PERIOD),       // Input clock period specified in nS
        .CLKOUT_PHASE_SHIFT("NONE"), //Output phase shift (NONE, FIXED, VARIABLE)
        .CLK_FEEDBACK("1X"),         // Feedback source (NONE, 1X, 2X)
        .DESKEW_ADJUST("SYSTEM_SYNCHRONOUS"), // SYSTEM_SYNCHRNOUS or SOURCE_SYNCHRONOUS
        .DFS_FREQUENCY_MODE("LOW"), // Unsupported - Do not change value
        .DLL_FREQUENCY_MODE("LOW"), // Unsupported - Do not change value
        .DSS_MODE("NONE"), // Unsupported - Do not change value
        .DUTY_CYCLE_CORRECTION("TRUE"), // Unsupported - Do not change value
        .FACTORY_JF(16'hc080), // Unsupported - Do not change value
        .PHASE_SHIFT(0), // Amount of fixed phase shift (-255 to 255)
        .STARTUP_WAIT("FALSE") // Delay config DONE until DCM_SP LOCKED (TRUE/FALSE)
    )
    DCM_SP_inst (
        .CLK0(), // 1-bit output: 0 degree clock output
        .CLK180(), // 1-bit output: 180 degree clock output
        .CLK270(), // 1-bit output: 270 degree clock output
        .CLK2X(), // 1-bit output: 2X clock frequency clock output
        .CLK2X180(), // 1-bit output: 2X clock frequency, 180 degree clock output
        .CLK90(), // 1-bit output: 90 degree clock output
        .CLKDV(), // 1-bit output: Divided clock output
        .CLKFX(cout), // 1-bit output: Digital Frequency Synthesizer output (DFS)
        .CLKFX180(), // 1-bit output: 180 degree CLKFX output
        .LOCKED(), // 1-bit output: DCM_SP Lock Output
        .PSDONE(), // 1-bit output: Phase shift done output
        .STATUS(), // 8-bit output: DCM_SP status output
        .CLKFB(), // 1-bit input: Clock feedback input
        .CLKIN(cin), // 1-bit input: Clock input
        .DSSEN(1'b0), // 1-bit input: Unsupported, specify to GND.
        .PSCLK(1'b0), // 1-bit input: Phase shift clock input
        .PSEN(1'b0), // 1-bit input: Phase shift enable
        .PSINCDEC(), // 1-bit input: Phase shift increment/decrement input
        .RST(1'b0) // 1-bit input: Active high reset input
    );
endmodule

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module DIG_ROM_32X4 (
    input [4:0] A,
    input sel,
    output reg [3:0] D
);
    reg [3:0] my_rom [0:31];

    always @ (*) begin
        if (~sel)
            D = 4'hz;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 4'h8;
        my_rom[1] = 4'h9;
        my_rom[2] = 4'ha;
        my_rom[3] = 4'hc;
        my_rom[4] = 4'hd;
        my_rom[5] = 4'he;
        my_rom[6] = 4'hf;
        my_rom[7] = 4'hf;
        my_rom[8] = 4'hf;
        my_rom[9] = 4'hf;
        my_rom[10] = 4'he;
        my_rom[11] = 4'hd;
        my_rom[12] = 4'hc;
        my_rom[13] = 4'hb;
        my_rom[14] = 4'ha;
        my_rom[15] = 4'h8;
        my_rom[16] = 4'h7;
        my_rom[17] = 4'h5;
        my_rom[18] = 4'h4;
        my_rom[19] = 4'h3;
        my_rom[20] = 4'h2;
        my_rom[21] = 4'h1;
        my_rom[22] = 4'h0;
        my_rom[23] = 4'h0;
        my_rom[24] = 4'h0;
        my_rom[25] = 4'h0;
        my_rom[26] = 4'h1;
        my_rom[27] = 4'h2;
        my_rom[28] = 4'h3;
        my_rom[29] = 4'h5;
        my_rom[30] = 4'h6;
        my_rom[31] = 4'h8;
    end
endmodule


module Pian (
  input clk,
  input enDo,
  input enRe,
  input enMi,
  input enFa,
  input enSol,
  input enLa,
  output [3:0] out // Salida 4 bits para DAC

);
  wire s0;
  wire [4:0] s1;
  wire cout;
  wire clk_divdo;
  wire [31:0] s2;
  wire clk_divre;
  wire [31:0] s3;
  wire clk_divmi;
  wire [31:0] s4;
  wire clk_divfa;
  wire [31:0] s5;
  wire clk_divsol;
  wire [31:0] s6;
  wire clk_divla;
  wire [31:0] s7;
  wire s_endo;
  wire coutdo;
  wire s_enre;
  wire coutre;
  wire s_enmi;
  wire coutmi;
  wire s_enfa;
  wire coutfa;
  wire s_ensol;
  wire coutsol;
  wire s_enla;
  wire coutla;
  assign s_endo = ~ enDo;
  assign s_enre = ~ enRe;
  assign s_enmi = ~ enMi;
  assign s_enfa = ~ enFa;
  assign s_ensol = ~ enSol;
  assign s_enla = ~ enLa;
  DIG_DCM_SP #(
    .CLKFX_DIVIDE(2),
    .CLKFX_MULTIPLY(2),
    .CLKIN_PERIOD(10.0)
  )
  DIG_DCM_SP_i0 (
    .cin( clk ),
    .cout( s0 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i1 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divdo ),
    .out( s2 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i2 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divre ),
    .out( s3 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i3 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divmi ),
    .out( s4 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i4 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divfa ),
    .out( s5 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i5 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divsol ),
    .out( s6 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i6 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divla ),
    .out( s7 )
  );
  Mux_2x1 Mux_2x1_i7 (
    .sel( s_endo ),
    .in_0( 1'b0 ),
    .in_1( clk_divdo ),
    .out( coutdo )
  );
  Mux_2x1 Mux_2x1_i8 (
    .sel( s_enre ),
    .in_0( 1'b0 ),
    .in_1( clk_divre ),
    .out( coutre )
  );
  Mux_2x1 Mux_2x1_i9 (
    .sel( s_enmi ),
    .in_0( 1'b0 ),
    .in_1( clk_divmi ),
    .out( coutmi )
  );
  Mux_2x1 Mux_2x1_i10 (
    .sel( s_enfa ),
    .in_0( 1'b0 ),
    .in_1( clk_divfa ),
    .out( coutfa )
  );
  Mux_2x1 Mux_2x1_i11 (
    .sel( s_ensol ),
    .in_0( 1'b0 ),
    .in_1( clk_divsol ),
    .out( coutsol )
  );
  Mux_2x1 Mux_2x1_i12 (
    .sel( s_enla ),
    .in_0( 1'b0 ),
    .in_1( clk_divla ),
    .out( coutla )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i13 (
    .a( 32'b10111010101000 ),
    .b( s2 ),
    .\= ( clk_divdo )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i14 (
    .a( 32'b10100110010010 ),
    .b( s3 ),
    .\= ( clk_divre )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i15 (
    .a( 32'b10010100001000 ),
    .b( s4 ),
    .\= ( clk_divmi )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i16 (
    .a( 32'b10001011110101 ),
    .b( s5 ),
    .\= ( clk_divfa )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i17 (
    .a( 32'b1111100100101 ),
    .b( s6 ),
    .\= ( clk_divsol )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i18 (
    .a( 32'b1101110111110 ),
    .b( s7 ),
    .\= ( clk_divla )
  );
  assign cout = (coutdo | coutre | coutmi | coutfa | coutsol | coutla);
  DIG_Counter_Nbit #(
    .Bits(5)
  )
  DIG_Counter_Nbit_i19 (
    .en( 1'b1 ),
    .C( cout ),
    .clr( 1'b0 ),
    .out( s1 )
  );
  DIG_ROM_32X4 DIG_ROM_32X4_i20 (
    .A( s1 ),
    .sel( 1'b1 ),
    .D( out )
  );
endmodule
